# Database Integrity Constraints
## College Canteen Manager System

---

## Table of Contents
1. [Domain Constraints](#1-domain-constraints)
2. [Entity Integrity Constraints](#2-entity-integrity-constraints)
3. [Referential Integrity Constraints](#3-referential-integrity-constraints)
4. [Key Constraints](#4-key-constraints)
5. [Business Rule Constraints](#5-business-rule-constraints)
6. [Validation Constraints](#6-validation-constraints)
7. [Constraint Implementation in Code](#7-constraint-implementation-in-code)

---

## 1. Domain Constraints

Domain constraints specify the permissible values for each attribute.

### 1.1 USER Collection

| Attribute | Data Type | Constraints | Description |
|-----------|-----------|-------------|-------------|
| name | String | `maxlength: 50`, `required: true`, `trim: true` | User's full name, cannot exceed 50 characters |
| email | String | `required: true`, `unique: true`, `lowercase: true`, `match: email regex` | Valid email format, case-insensitive |
| passwordHash | String | `required: true`, `minlength: 6`, `select: false` | Encrypted password, minimum 6 characters before hashing |
| role | Enum | `enum: ['student', 'staff', 'admin']`, `default: 'student'` | Only three predefined roles allowed |
| refreshToken | String | `select: false` | JWT refresh token, not returned by default |

**Email Validation Regex:**
```javascript
/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/
```

### 1.2 MENUITEM Collection

| Attribute | Data Type | Constraints | Description |
|-----------|-----------|-------------|-------------|
| name | String | `required: true`, `maxlength: 100`, `trim: true` | Item name, cannot exceed 100 characters |
| description | String | `maxlength: 500`, `trim: true` | Optional description, max 500 characters |
| category | Enum | `required: true`, `enum: ['snacks', 'drinks', 'meals', 'desserts', 'beverages']` | Must be one of 5 predefined categories |
| price | Number | `required: true`, `min: 0` | Must be non-negative number |
| isVeg | Boolean | `default: true` | Boolean flag for vegetarian items |
| availableStock | Number | `required: true`, `min: 0`, `default: 0` | Non-negative integer for stock count |
| imageURL | String | `default: 'https://via.placeholder.com/300x200?text=Food+Item'` | URL string with default placeholder |
| isActive | Boolean | `default: true` | Boolean flag for item availability |

### 1.3 ORDER Collection

| Attribute | Data Type | Constraints | Description |
|-----------|-----------|-------------|-------------|
| userId | ObjectId | `required: true`, `ref: 'User'` | Must reference valid User document |
| orderToken | String | `required: true`, `unique: true` | Unique token for each order |
| items | Array | `required: true`, `validate: length > 0` | Must contain at least one order item |
| paymentMode | Enum | `required: true`, `enum: ['counter', 'online']`, `default: 'counter'` | Only two payment modes allowed |
| totalAmount | Number | `required: true`, `min: 0` | Must be non-negative number |
| status | Enum | `required: true`, `enum: ['Placed', 'In Preparation', 'Ready', 'Completed', 'Cancelled']`, `default: 'Placed'` | Must be one of 5 predefined statuses |

### 1.4 ORDER_ITEM Sub-Document

| Attribute | Data Type | Constraints | Description |
|-----------|-----------|-------------|-------------|
| itemId | ObjectId | `required: true`, `ref: 'MenuItem'` | Must reference valid MenuItem |
| name | String | `required: true` | Item name snapshot |
| price | Number | `required: true`, `min: 0` | Price snapshot, non-negative |
| qty | Number | `required: true`, `min: 1` | Quantity must be at least 1 |

---

## 2. Entity Integrity Constraints

Ensures that each entity has a unique identifier and no null primary keys.

### 2.1 Primary Key Constraints

| Collection | Primary Key | Type | Constraint |
|------------|-------------|------|------------|
| users | _id | ObjectId | Automatically generated by MongoDB, unique, not null |
| menuitems | _id | ObjectId | Automatically generated by MongoDB, unique, not null |
| orders | _id | ObjectId | Automatically generated by MongoDB, unique, not null |
| counters | _id | ObjectId | Automatically generated by MongoDB, unique, not null |

**Implementation:**
```javascript
// MongoDB automatically ensures:
// 1. _id field exists in every document
// 2. _id is unique within the collection
// 3. _id cannot be null or undefined
```

---

## 3. Referential Integrity Constraints

Ensures relationships between collections remain consistent.

### 3.1 Foreign Key Relationships

#### Order → User Relationship
```javascript
// In Order schema
userId: {
  type: mongoose.Schema.Types.ObjectId,
  ref: 'User',
  required: [true, 'User ID is required']
}
```

**Constraints:**
- Every order MUST have a valid userId
- userId MUST reference an existing User document
- Enforced through application logic and Mongoose population

#### Order Item → MenuItem Relationship
```javascript
// In OrderItem sub-schema
itemId: {
  type: mongoose.Schema.Types.ObjectId,
  ref: 'MenuItem',
  required: true
}
```

**Constraints:**
- Every order item MUST have a valid itemId
- itemId SHOULD reference an existing MenuItem (soft reference)
- Denormalized data (name, price) allows orders to persist even if menu item is deleted

### 3.2 Cascade Rules

| Parent | Child | On Delete | On Update |
|--------|-------|-----------|-----------|
| User | Order | RESTRICT (handled in application) | CASCADE |
| MenuItem | Order Item | NO ACTION (historical data preserved) | NO ACTION |

**Note:** MongoDB doesn't enforce referential integrity at the database level. These rules are enforced through application logic.

---

## 4. Key Constraints

### 4.1 Unique Constraints

| Collection | Attribute | Uniqueness | Enforcement |
|------------|-----------|------------|-------------|
| users | email | UNIQUE | Database index: `{ email: 1 }` |
| orders | orderToken | UNIQUE | Database index: `{ orderToken: 1 }` |
| counters | name | UNIQUE | Database index: `{ name: 1 }` |

**Implementation:**
```javascript
// User schema
email: {
  type: String,
  required: [true, 'Please provide an email'],
  unique: true,
  lowercase: true
}

// Order schema
orderToken: {
  type: String,
  required: true,
  unique: true
}

// Counter schema
name: {
  type: String,
  required: true,
  unique: true
}
```

### 4.2 Composite Keys

While MongoDB doesn't support traditional composite keys, we enforce uniqueness through compound indexes:

```javascript
// Compound index for efficient querying
userSchema.index({ email: 1 });
orderSchema.index({ userId: 1, createdAt: -1 });
menuItemSchema.index({ category: 1, isActive: 1 });
```

---

## 5. Business Rule Constraints

### 5.1 Order Validation Rules

#### Rule 1: Order Must Have Items
```javascript
items: {
  type: [orderItemSchema],
  required: [true, 'Order must have at least one item'],
  validate: {
    validator: function(v) {
      return v && v.length > 0;
    },
    message: 'Order must contain at least one item'
  }
}
```

#### Rule 2: Total Amount Calculation
```javascript
// Application logic ensures:
// totalAmount = sum(items[i].price * items[i].qty)
// This is validated before order creation
```

#### Rule 3: Stock Availability
```javascript
// Before order placement, application checks:
// - menuItem.availableStock >= orderItem.qty
// - menuItem.isActive === true
```

### 5.2 User Authentication Rules

#### Rule 1: Password Strength
```javascript
passwordHash: {
  type: String,
  required: [true, 'Please provide a password'],
  minlength: 6  // Enforced before hashing
}
```

#### Rule 2: Password Hashing
```javascript
// Pre-save middleware ensures password is always hashed
userSchema.pre('save', async function(next) {
  if (!this.isModified('passwordHash')) {
    return next();
  }
  const salt = await bcrypt.genSalt(10);
  this.passwordHash = await bcrypt.hash(this.passwordHash, salt);
  next();
});
```

### 5.3 Menu Item Rules

#### Rule 1: Price Non-Negative
```javascript
price: {
  type: Number,
  required: [true, 'Please provide a price'],
  min: [0, 'Price cannot be negative']
}
```

#### Rule 2: Stock Non-Negative
```javascript
availableStock: {
  type: Number,
  required: [true, 'Please provide stock quantity'],
  min: [0, 'Stock cannot be negative'],
  default: 0
}
```

#### Rule 3: Availability Logic
```javascript
// Virtual property for computed availability
menuItemSchema.virtual('isAvailable').get(function() {
  return this.isActive && this.availableStock > 0;
});
```

---

## 6. Validation Constraints

### 6.1 Format Validation

#### Email Format
```javascript
email: {
  type: String,
  match: [
    /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/,
    'Please provide a valid email'
  ]
}
```

#### String Length Validation
```javascript
// User name
name: {
  maxlength: [50, 'Name cannot be more than 50 characters']
}

// Menu item name
name: {
  maxlength: [100, 'Item name cannot exceed 100 characters']
}

// Menu item description
description: {
  maxlength: [500, 'Description cannot exceed 500 characters']
}
```

### 6.2 Enum Validation

```javascript
// User role validation
role: {
  type: String,
  enum: ['student', 'staff', 'admin'],
  default: 'student'
}

// Menu category validation
category: {
  type: String,
  enum: ['snacks', 'drinks', 'meals', 'desserts', 'beverages']
}

// Payment mode validation
paymentMode: {
  type: String,
  enum: ['counter', 'online'],
  default: 'counter'
}

// Order status validation
status: {
  type: String,
  enum: ['Placed', 'In Preparation', 'Ready', 'Completed', 'Cancelled'],
  default: 'Placed'
}
```

---

## 7. Constraint Implementation in Code

### 7.1 Model-Level Constraints

#### User Model (User.js)
```javascript
const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Please provide a name'],
    trim: true,
    maxlength: [50, 'Name cannot be more than 50 characters']
  },
  email: {
    type: String,
    required: [true, 'Please provide an email'],
    unique: true,
    lowercase: true,
    trim: true,
    match: [
      /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/,
      'Please provide a valid email'
    ]
  },
  passwordHash: {
    type: String,
    required: [true, 'Please provide a password'],
    minlength: 6,
    select: false
  },
  role: {
    type: String,
    enum: ['student', 'staff', 'admin'],
    default: 'student'
  }
});

// Indexes for constraints
userSchema.index({ email: 1 });
userSchema.index({ role: 1 });
```

#### MenuItem Model (MenuItem.js)
```javascript
const menuItemSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Please provide item name'],
    trim: true,
    maxlength: [100, 'Item name cannot exceed 100 characters']
  },
  category: {
    type: String,
    required: [true, 'Please provide a category'],
    enum: ['snacks', 'drinks', 'meals', 'desserts', 'beverages'],
    default: 'snacks'
  },
  price: {
    type: Number,
    required: [true, 'Please provide a price'],
    min: [0, 'Price cannot be negative']
  },
  availableStock: {
    type: Number,
    required: [true, 'Please provide stock quantity'],
    min: [0, 'Stock cannot be negative'],
    default: 0
  }
});

// Indexes for performance and constraints
menuItemSchema.index({ category: 1, isActive: 1 });
menuItemSchema.index({ name: 'text' });
menuItemSchema.index({ price: 1 });
```

#### Order Model (Order.js)
```javascript
const orderSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'User ID is required']
  },
  orderToken: {
    type: String,
    required: true,
    unique: true
  },
  items: {
    type: [orderItemSchema],
    required: [true, 'Order must have at least one item'],
    validate: {
      validator: function(v) {
        return v && v.length > 0;
      },
      message: 'Order must contain at least one item'
    }
  },
  totalAmount: {
    type: Number,
    required: [true, 'Total amount is required'],
    min: [0, 'Total amount cannot be negative']
  },
  status: {
    type: String,
    enum: ['Placed', 'In Preparation', 'Ready', 'Completed', 'Cancelled'],
    default: 'Placed'
  }
});

// Indexes for constraints and performance
orderSchema.index({ userId: 1, createdAt: -1 });
orderSchema.index({ orderToken: 1 });
orderSchema.index({ status: 1 });
```

### 7.2 Application-Level Constraints

#### Authentication Constraints
```javascript
// In authController.js - Registration
exports.register = async (req, res) => {
  try {
    const { name, email, password, role } = req.body;

    // Check if user exists (UNIQUE constraint enforcement)
    const userExists = await User.findOne({ email });
    if (userExists) {
      return res.status(400).json({
        success: false,
        message: 'User already exists with this email'
      });
    }

    // Create user (triggers validation constraints)
    const user = await User.create({
      name,
      email,
      passwordHash: password,
      role: role || 'student'
    });

    // ... rest of the code
  } catch (error) {
    // Handles validation errors
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

#### Order Placement Constraints
```javascript
// In orderController.js
// Before creating order:
// 1. Validate stock availability
// 2. Check menu item is active
// 3. Calculate total amount
// 4. Generate unique order token

const item = await MenuItem.findById(orderItem.itemId);

// Constraint checks
if (!item) {
  throw new Error('Menu item not found');
}
if (!item.isActive) {
  throw new Error('Menu item is not available');
}
if (item.availableStock < orderItem.qty) {
  throw new Error('Insufficient stock');
}
```

---

## 8. Constraint Violation Handling

### 8.1 Error Types and Responses

| Constraint Type | Error Code | HTTP Status | Example Message |
|----------------|------------|-------------|-----------------|
| Required Field | ValidationError | 400 | "Please provide a name" |
| Unique Violation | 11000 | 400 | "User already exists with this email" |
| Invalid Enum | ValidationError | 400 | "Invalid role. Must be student, staff, or admin" |
| Range Violation | ValidationError | 400 | "Price cannot be negative" |
| Format Violation | ValidationError | 400 | "Please provide a valid email" |
| Foreign Key | CastError | 400 | "Invalid user ID" |

### 8.2 Error Handling Pattern

```javascript
try {
  // Database operation
  await Model.create(data);
} catch (error) {
  if (error.name === 'ValidationError') {
    // Handle validation constraint violations
    return res.status(400).json({
      success: false,
      message: error.message
    });
  }
  
  if (error.code === 11000) {
    // Handle unique constraint violations
    return res.status(400).json({
      success: false,
      message: 'Duplicate value for unique field'
    });
  }
  
  // Handle other errors
  res.status(500).json({
    success: false,
    message: 'Internal server error'
  });
}
```

---

## 9. Summary of All Constraints

### USER Collection
✅ Required: name, email, passwordHash  
✅ Unique: email  
✅ Enum: role (student, staff, admin)  
✅ Length: name ≤ 50, password ≥ 6  
✅ Format: email (regex validation)  
✅ Index: email, role  

### MENUITEM Collection
✅ Required: name, category, price, availableStock  
✅ Enum: category (5 types)  
✅ Range: price ≥ 0, availableStock ≥ 0  
✅ Length: name ≤ 100, description ≤ 500  
✅ Index: category+isActive, name (text), price  

### ORDER Collection
✅ Required: userId, orderToken, items, paymentMode, totalAmount, status  
✅ Unique: orderToken  
✅ Foreign Key: userId → User  
✅ Enum: paymentMode (2 types), status (5 types)  
✅ Range: totalAmount ≥ 0  
✅ Custom: items array length > 0  
✅ Index: userId+createdAt, orderToken, status  

### ORDER_ITEM Sub-Document
✅ Required: itemId, name, price, qty  
✅ Foreign Key: itemId → MenuItem  
✅ Range: price ≥ 0, qty ≥ 1  

---

## 10. Testing Constraints

### Sample Test Cases

```javascript
// Test 1: User with invalid email
try {
  await User.create({
    name: "Test User",
    email: "invalid-email",  // Should fail
    passwordHash: "password123"
  });
} catch (error) {
  // Expected: ValidationError
}

// Test 2: Duplicate email
try {
  await User.create({
    name: "User 1",
    email: "test@test.com",
    passwordHash: "password123"
  });
  
  await User.create({
    name: "User 2",
    email: "test@test.com",  // Should fail
    passwordHash: "password456"
  });
} catch (error) {
  // Expected: Error code 11000
}

// Test 3: Negative price
try {
  await MenuItem.create({
    name: "Invalid Item",
    category: "snacks",
    price: -10,  // Should fail
    availableStock: 50
  });
} catch (error) {
  // Expected: ValidationError
}

// Test 4: Empty order items
try {
  await Order.create({
    userId: validUserId,
    orderToken: "1001",
    items: [],  // Should fail
    paymentMode: "counter",
    totalAmount: 0
  });
} catch (error) {
  // Expected: ValidationError
}
```
